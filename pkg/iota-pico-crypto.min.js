!function(e,t){"object"==typeof exports&&"object"==typeof module?module.exports=t(require("@iota-pico/core/dist/helpers/objectHelper"),require("@iota-pico/core/dist/helpers/numberHelper"),require("@iota-pico/data/dist/data/hash"),require("@iota-pico/core/dist/factories/factoryBase"),require("@iota-pico/core/dist/helpers/arrayHelper"),require("@iota-pico/data/dist/data/trits"),require("@iota-pico/data/dist/data/trytes"),require("@iota-pico/data/dist/data/transaction"),require("@iota-pico/core/dist/error/coreError"),require("big-integer"),require("@iota-pico/data/dist/data/address"),require("@iota-pico/data/dist/data/addressSecurity"),require("@iota-pico/data/dist/data/signatureMessageFragment"),require("@iota-pico/core/dist/services/timeService"),require("@iota-pico/data/dist/data/tag"),require("@iota-pico/data/dist/data/tryteNumber")):"function"==typeof define&&define.amd?define("@iota-pico/crypto",["@iota-pico/core/dist/helpers/objectHelper","@iota-pico/core/dist/helpers/numberHelper","@iota-pico/data/dist/data/hash","@iota-pico/core/dist/factories/factoryBase","@iota-pico/core/dist/helpers/arrayHelper","@iota-pico/data/dist/data/trits","@iota-pico/data/dist/data/trytes","@iota-pico/data/dist/data/transaction","@iota-pico/core/dist/error/coreError","big-integer","@iota-pico/data/dist/data/address","@iota-pico/data/dist/data/addressSecurity","@iota-pico/data/dist/data/signatureMessageFragment","@iota-pico/core/dist/services/timeService","@iota-pico/data/dist/data/tag","@iota-pico/data/dist/data/tryteNumber"],t):"object"==typeof exports?exports["@iota-pico/crypto"]=t(require("@iota-pico/core/dist/helpers/objectHelper"),require("@iota-pico/core/dist/helpers/numberHelper"),require("@iota-pico/data/dist/data/hash"),require("@iota-pico/core/dist/factories/factoryBase"),require("@iota-pico/core/dist/helpers/arrayHelper"),require("@iota-pico/data/dist/data/trits"),require("@iota-pico/data/dist/data/trytes"),require("@iota-pico/data/dist/data/transaction"),require("@iota-pico/core/dist/error/coreError"),require("big-integer"),require("@iota-pico/data/dist/data/address"),require("@iota-pico/data/dist/data/addressSecurity"),require("@iota-pico/data/dist/data/signatureMessageFragment"),require("@iota-pico/core/dist/services/timeService"),require("@iota-pico/data/dist/data/tag"),require("@iota-pico/data/dist/data/tryteNumber")):e.IotaPicoCrypto=t(e["@iota-pico/core/dist/helpers/objectHelper"],e["@iota-pico/core/dist/helpers/numberHelper"],e["@iota-pico/data/dist/data/hash"],e["@iota-pico/core/dist/factories/factoryBase"],e["@iota-pico/core/dist/helpers/arrayHelper"],e["@iota-pico/data/dist/data/trits"],e["@iota-pico/data/dist/data/trytes"],e["@iota-pico/data/dist/data/transaction"],e["@iota-pico/core/dist/error/coreError"],e.bigInt,e["@iota-pico/data/dist/data/address"],e["@iota-pico/data/dist/data/addressSecurity"],e["@iota-pico/data/dist/data/signatureMessageFragment"],e["@iota-pico/core/dist/services/timeService"],e["@iota-pico/data/dist/data/tag"],e["@iota-pico/data/dist/data/tryteNumber"])}("undefined"!=typeof self?self:this,function(e,t,r,o,n,i,s,a,c,u,l,p,f,y,h,d){return function(e){var t={};function r(o){if(t[o])return t[o].exports;var n=t[o]={i:o,l:!1,exports:{}};return e[o].call(n.exports,n,n.exports,r),n.l=!0,n.exports}return r.m=e,r.c=t,r.d=function(e,t,o){r.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:o})},r.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},r.t=function(e,t){if(1&t&&(e=r(e)),8&t)return e;if(4&t&&"object"==typeof e&&e&&e.__esModule)return e;var o=Object.create(null);if(r.r(o),Object.defineProperty(o,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var n in e)r.d(o,n,function(t){return e[t]}.bind(null,n));return o},r.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return r.d(t,"a",t),t},r.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},r.p="",r(r.s=16)}([function(e,t,r){Object.defineProperty(t,"__esModule",{value:!0});const o=r(17);t.CryptoError=class extends o.CoreError{constructor(e,t,r){super(e,t,r),this.domain="Crypto"}}},function(t,r){t.exports=e},function(e,r){e.exports=t},function(e,t,r){"use strict";r.r(t),r.d(t,"__extends",function(){return n}),r.d(t,"__assign",function(){return i}),r.d(t,"__rest",function(){return s}),r.d(t,"__decorate",function(){return a}),r.d(t,"__param",function(){return c}),r.d(t,"__metadata",function(){return u}),r.d(t,"__awaiter",function(){return l}),r.d(t,"__generator",function(){return p}),r.d(t,"__exportStar",function(){return f}),r.d(t,"__values",function(){return y}),r.d(t,"__read",function(){return h}),r.d(t,"__spread",function(){return d}),r.d(t,"__await",function(){return _}),r.d(t,"__asyncGenerator",function(){return b}),r.d(t,"__asyncDelegator",function(){return T}),r.d(t,"__asyncValues",function(){return g}),r.d(t,"__makeTemplateObject",function(){return H}),r.d(t,"__importStar",function(){return w}),r.d(t,"__importDefault",function(){return m});
/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
var o=function(e,t){return(o=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,t){e.__proto__=t}||function(e,t){for(var r in t)t.hasOwnProperty(r)&&(e[r]=t[r])})(e,t)};function n(e,t){function r(){this.constructor=e}o(e,t),e.prototype=null===t?Object.create(t):(r.prototype=t.prototype,new r)}var i=function(){return(i=Object.assign||function(e){for(var t,r=1,o=arguments.length;r<o;r++)for(var n in t=arguments[r])Object.prototype.hasOwnProperty.call(t,n)&&(e[n]=t[n]);return e}).apply(this,arguments)};function s(e,t){var r={};for(var o in e)Object.prototype.hasOwnProperty.call(e,o)&&t.indexOf(o)<0&&(r[o]=e[o]);if(null!=e&&"function"==typeof Object.getOwnPropertySymbols){var n=0;for(o=Object.getOwnPropertySymbols(e);n<o.length;n++)t.indexOf(o[n])<0&&(r[o[n]]=e[o[n]])}return r}function a(e,t,r,o){var n,i=arguments.length,s=i<3?t:null===o?o=Object.getOwnPropertyDescriptor(t,r):o;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)s=Reflect.decorate(e,t,r,o);else for(var a=e.length-1;a>=0;a--)(n=e[a])&&(s=(i<3?n(s):i>3?n(t,r,s):n(t,r))||s);return i>3&&s&&Object.defineProperty(t,r,s),s}function c(e,t){return function(r,o){t(r,o,e)}}function u(e,t){if("object"==typeof Reflect&&"function"==typeof Reflect.metadata)return Reflect.metadata(e,t)}function l(e,t,r,o){return new(r||(r=Promise))(function(n,i){function s(e){try{c(o.next(e))}catch(e){i(e)}}function a(e){try{c(o.throw(e))}catch(e){i(e)}}function c(e){e.done?n(e.value):new r(function(t){t(e.value)}).then(s,a)}c((o=o.apply(e,t||[])).next())})}function p(e,t){var r,o,n,i,s={label:0,sent:function(){if(1&n[0])throw n[1];return n[1]},trys:[],ops:[]};return i={next:a(0),throw:a(1),return:a(2)},"function"==typeof Symbol&&(i[Symbol.iterator]=function(){return this}),i;function a(i){return function(a){return function(i){if(r)throw new TypeError("Generator is already executing.");for(;s;)try{if(r=1,o&&(n=2&i[0]?o.return:i[0]?o.throw||((n=o.return)&&n.call(o),0):o.next)&&!(n=n.call(o,i[1])).done)return n;switch(o=0,n&&(i=[2&i[0],n.value]),i[0]){case 0:case 1:n=i;break;case 4:return s.label++,{value:i[1],done:!1};case 5:s.label++,o=i[1],i=[0];continue;case 7:i=s.ops.pop(),s.trys.pop();continue;default:if(!(n=(n=s.trys).length>0&&n[n.length-1])&&(6===i[0]||2===i[0])){s=0;continue}if(3===i[0]&&(!n||i[1]>n[0]&&i[1]<n[3])){s.label=i[1];break}if(6===i[0]&&s.label<n[1]){s.label=n[1],n=i;break}if(n&&s.label<n[2]){s.label=n[2],s.ops.push(i);break}n[2]&&s.ops.pop(),s.trys.pop();continue}i=t.call(e,s)}catch(e){i=[6,e],o=0}finally{r=n=0}if(5&i[0])throw i[1];return{value:i[0]?i[1]:void 0,done:!0}}([i,a])}}}function f(e,t){for(var r in e)t.hasOwnProperty(r)||(t[r]=e[r])}function y(e){var t="function"==typeof Symbol&&e[Symbol.iterator],r=0;return t?t.call(e):{next:function(){return e&&r>=e.length&&(e=void 0),{value:e&&e[r++],done:!e}}}}function h(e,t){var r="function"==typeof Symbol&&e[Symbol.iterator];if(!r)return e;var o,n,i=r.call(e),s=[];try{for(;(void 0===t||t-- >0)&&!(o=i.next()).done;)s.push(o.value)}catch(e){n={error:e}}finally{try{o&&!o.done&&(r=i.return)&&r.call(i)}finally{if(n)throw n.error}}return s}function d(){for(var e=[],t=0;t<arguments.length;t++)e=e.concat(h(arguments[t]));return e}function _(e){return this instanceof _?(this.v=e,this):new _(e)}function b(e,t,r){if(!Symbol.asyncIterator)throw new TypeError("Symbol.asyncIterator is not defined.");var o,n=r.apply(e,t||[]),i=[];return o={},s("next"),s("throw"),s("return"),o[Symbol.asyncIterator]=function(){return this},o;function s(e){n[e]&&(o[e]=function(t){return new Promise(function(r,o){i.push([e,t,r,o])>1||a(e,t)})})}function a(e,t){try{(r=n[e](t)).value instanceof _?Promise.resolve(r.value.v).then(c,u):l(i[0][2],r)}catch(e){l(i[0][3],e)}var r}function c(e){a("next",e)}function u(e){a("throw",e)}function l(e,t){e(t),i.shift(),i.length&&a(i[0][0],i[0][1])}}function T(e){var t,r;return t={},o("next"),o("throw",function(e){throw e}),o("return"),t[Symbol.iterator]=function(){return this},t;function o(o,n){t[o]=e[o]?function(t){return(r=!r)?{value:_(e[o](t)),done:"return"===o}:n?n(t):t}:n}}function g(e){if(!Symbol.asyncIterator)throw new TypeError("Symbol.asyncIterator is not defined.");var t,r=e[Symbol.asyncIterator];return r?r.call(e):(e=y(e),t={},o("next"),o("throw"),o("return"),t[Symbol.asyncIterator]=function(){return this},t);function o(r){t[r]=e[r]&&function(t){return new Promise(function(o,n){(function(e,t,r,o){Promise.resolve(o).then(function(t){e({value:t,done:r})},t)})(o,n,(t=e[r](t)).done,t.value)})}}}function H(e,t){return Object.defineProperty?Object.defineProperty(e,"raw",{value:t}):e.raw=t,e}function w(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r in e)Object.hasOwnProperty.call(e,r)&&(t[r]=e[r]);return t.default=e,t}function m(e){return e&&e.__esModule?e:{default:e}}},function(e,t,r){Object.defineProperty(t,"__esModule",{value:!0});const o=r(7),n=r(8),i=r(9);class s extends o.FactoryBase{constructor(){super()}static instance(){return s._instance||(s._instance=new s,s._instance.register("curl",(...e)=>new n.Curl(...e)),s._instance.register("curl81",(...e)=>new n.Curl(81)),s._instance.register("curl27",(...e)=>new n.Curl(27)),s._instance.register("kerl",(...e)=>new i.Kerl)),s._instance}getInstance(){return s.instance()}}t.SpongeFactory=s},function(e,t){e.exports=r},function(e,t,r){Object.defineProperty(t,"__esModule",{value:!0});const o=r(1),n=r(0);class i{constructor(e,t,r){this._padding=t,this._outputBits=r,this._blockCount=1600-(e<<1)>>5,this._byteCount=this._blockCount<<2,this._outputBlocks=r>>5,this._extraBytes=(31&r)>>3,this.reset()}reset(){this._reset=!0,this._block=0,this._start=0,this._blocks=new Uint32Array(this._blockCount+1),this._state=new Uint32Array(50)}update(e){if(!o.ObjectHelper.isType(e,ArrayBuffer))throw new n.CryptoError("Input is not of type ArrayBuffer");const t=new Uint8Array(e),r=t.length;let s,a=0;for(;a<r;){if(this._reset)for(this._reset=!1,this._blocks[0]=this._block,s=1;s<this._blockCount+1;++s)this._blocks[s]=0;for(s=this._start;a<r&&s<this._byteCount;++a)this._blocks[s>>2]|=t[a]<<i.SHIFT[3&s++];if(this._lastByteIndex=s,s>=this._byteCount){for(this._start=s-this._byteCount,this._block=this._blocks[this._blockCount],s=0;s<this._blockCount;++s)this._state[s]^=this._blocks[s];this.keccakPermutation(this._state),this._reset=!0}else this._start=s}}digest(){this.finalize();let e=0,t=0;const r=this._outputBits>>3;let o;o=this._extraBytes?new ArrayBuffer(this._outputBlocks+1<<2):new ArrayBuffer(r);const n=new Uint32Array(o);for(;t<this._outputBlocks;)for(e=0;e<this._blockCount&&t<this._outputBlocks;++e,++t)n[t]=this._state[e];return this._extraBytes&&(n[e]=this._state[e],o=o.slice(0,r)),this.reset(),o}finalize(){let e=this._lastByteIndex;if(this._blocks[e>>2]|=this._padding[3&e],this._lastByteIndex===this._byteCount)for(this._blocks[0]=this._blocks[this._blockCount],e=1;e<this._blockCount+1;++e)this._blocks[e]=0;for(this._blocks[this._blockCount-1]|=2147483648,e=0;e<this._blockCount;++e)this._state[e]^=this._blocks[e];this.keccakPermutation(this._state)}keccakPermutation(e){let t,r,o,n,s,a,c,u,l,p,f,y,h,d,_,b,T,g,H,w,m,E,A,S,N,I,C,O,L,v,M,x,B,R,U,G,j,F,k,q,P,z,V,D,Y,$,X,K,W,J,Q,Z,ee,te,re,oe,ne,ie,se,ae,ce,ue,le;for(o=0;o<48;o+=2)n=e[0]^e[10]^e[20]^e[30]^e[40],s=e[1]^e[11]^e[21]^e[31]^e[41],a=e[2]^e[12]^e[22]^e[32]^e[42],c=e[3]^e[13]^e[23]^e[33]^e[43],u=e[4]^e[14]^e[24]^e[34]^e[44],l=e[5]^e[15]^e[25]^e[35]^e[45],p=e[6]^e[16]^e[26]^e[36]^e[46],f=e[7]^e[17]^e[27]^e[37]^e[47],t=(y=e[8]^e[18]^e[28]^e[38]^e[48])^(a<<1|c>>>31),r=(h=e[9]^e[19]^e[29]^e[39]^e[49])^(c<<1|a>>>31),e[0]^=t,e[1]^=r,e[10]^=t,e[11]^=r,e[20]^=t,e[21]^=r,e[30]^=t,e[31]^=r,e[40]^=t,e[41]^=r,t=n^(u<<1|l>>>31),r=s^(l<<1|u>>>31),e[2]^=t,e[3]^=r,e[12]^=t,e[13]^=r,e[22]^=t,e[23]^=r,e[32]^=t,e[33]^=r,e[42]^=t,e[43]^=r,t=a^(p<<1|f>>>31),r=c^(f<<1|p>>>31),e[4]^=t,e[5]^=r,e[14]^=t,e[15]^=r,e[24]^=t,e[25]^=r,e[34]^=t,e[35]^=r,e[44]^=t,e[45]^=r,t=u^(y<<1|h>>>31),r=l^(h<<1|y>>>31),e[6]^=t,e[7]^=r,e[16]^=t,e[17]^=r,e[26]^=t,e[27]^=r,e[36]^=t,e[37]^=r,e[46]^=t,e[47]^=r,t=p^(n<<1|s>>>31),r=f^(s<<1|n>>>31),e[8]^=t,e[9]^=r,e[18]^=t,e[19]^=r,e[28]^=t,e[29]^=r,e[38]^=t,e[39]^=r,e[48]^=t,e[49]^=r,d=e[0],_=e[1],$=e[11]<<4|e[10]>>>28,X=e[10]<<4|e[11]>>>28,O=e[20]<<3|e[21]>>>29,L=e[21]<<3|e[20]>>>29,ae=e[31]<<9|e[30]>>>23,ce=e[30]<<9|e[31]>>>23,z=e[40]<<18|e[41]>>>14,V=e[41]<<18|e[40]>>>14,R=e[2]<<1|e[3]>>>31,U=e[3]<<1|e[2]>>>31,b=e[13]<<12|e[12]>>>20,T=e[12]<<12|e[13]>>>20,K=e[22]<<10|e[23]>>>22,W=e[23]<<10|e[22]>>>22,v=e[33]<<13|e[32]>>>19,M=e[32]<<13|e[33]>>>19,ue=e[42]<<2|e[43]>>>30,le=e[43]<<2|e[42]>>>30,te=e[5]<<30|e[4]>>>2,re=e[4]<<30|e[5]>>>2,G=e[14]<<6|e[15]>>>26,j=e[15]<<6|e[14]>>>26,g=e[25]<<11|e[24]>>>21,H=e[24]<<11|e[25]>>>21,J=e[34]<<15|e[35]>>>17,Q=e[35]<<15|e[34]>>>17,x=e[45]<<29|e[44]>>>3,B=e[44]<<29|e[45]>>>3,S=e[6]<<28|e[7]>>>4,N=e[7]<<28|e[6]>>>4,oe=e[17]<<23|e[16]>>>9,ne=e[16]<<23|e[17]>>>9,F=e[26]<<25|e[27]>>>7,k=e[27]<<25|e[26]>>>7,w=e[36]<<21|e[37]>>>11,m=e[37]<<21|e[36]>>>11,Z=e[47]<<24|e[46]>>>8,ee=e[46]<<24|e[47]>>>8,D=e[8]<<27|e[9]>>>5,Y=e[9]<<27|e[8]>>>5,I=e[18]<<20|e[19]>>>12,C=e[19]<<20|e[18]>>>12,ie=e[29]<<7|e[28]>>>25,se=e[28]<<7|e[29]>>>25,q=e[38]<<8|e[39]>>>24,P=e[39]<<8|e[38]>>>24,E=e[48]<<14|e[49]>>>18,A=e[49]<<14|e[48]>>>18,e[0]=d^~b&g,e[1]=_^~T&H,e[10]=S^~I&O,e[11]=N^~C&L,e[20]=R^~G&F,e[21]=U^~j&k,e[30]=D^~$&K,e[31]=Y^~X&W,e[40]=te^~oe&ie,e[41]=re^~ne&se,e[2]=b^~g&w,e[3]=T^~H&m,e[12]=I^~O&v,e[13]=C^~L&M,e[22]=G^~F&q,e[23]=j^~k&P,e[32]=$^~K&J,e[33]=X^~W&Q,e[42]=oe^~ie&ae,e[43]=ne^~se&ce,e[4]=g^~w&E,e[5]=H^~m&A,e[14]=O^~v&x,e[15]=L^~M&B,e[24]=F^~q&z,e[25]=k^~P&V,e[34]=K^~J&Z,e[35]=W^~Q&ee,e[44]=ie^~ae&ue,e[45]=se^~ce&le,e[6]=w^~E&d,e[7]=m^~A&_,e[16]=v^~x&S,e[17]=M^~B&N,e[26]=q^~z&R,e[27]=P^~V&U,e[36]=J^~Z&D,e[37]=Q^~ee&Y,e[46]=ae^~ue&te,e[47]=ce^~le&re,e[8]=E^~d&b,e[9]=A^~_&T,e[18]=x^~S&I,e[19]=B^~N&C,e[28]=z^~R&G,e[29]=V^~U&j,e[38]=Z^~D&$,e[39]=ee^~Y&X,e[48]=ue^~te&oe,e[49]=le^~re&ne,e[0]^=i.ROUND_CONSTANTS[o],e[1]^=i.ROUND_CONSTANTS[o+1]}}i.KECCAK_PADDING=new Uint32Array([1,256,65536,16777216]),i.SHIFT=new Uint8Array([0,8,16,24]),i.ROUND_CONSTANTS=new Uint32Array([1,0,32898,0,32906,2147483648,2147516416,2147483648,32907,0,2147483649,0,2147516545,2147483648,32777,2147483648,138,0,136,0,2147516425,0,2147483658,0,2147516555,0,139,2147483648,32905,2147483648,32771,2147483648,32770,2147483648,128,2147483648,32778,0,2147483658,2147483648,2147516545,2147483648,32896,2147483648,2147483649,0,2147516424,2147483648]),t.Sha3=i},function(e,t){e.exports=o},function(e,t,r){Object.defineProperty(t,"__esModule",{value:!0});const o=r(2),n=r(1),i=r(0);class s{constructor(e=s.NUMBER_OF_ROUNDS){this._numberOfRounds=e}getConstant(e){switch(e){case"NUMBER_OF_ROUNDS":return this._numberOfRounds;case"HASH_LENGTH":case"STATE_LENGTH":return s[e];default:throw new i.CryptoError(`Unknown constant requested ${e}`)}}getState(){return this._state}initialize(e){this._state=e||new Int8Array(s.STATE_LENGTH)}reset(){this.initialize()}absorb(e,t,r){if(!n.ObjectHelper.isType(e,Int8Array)||0===e.length)throw new i.CryptoError("Trits must be a non empty Int8Array");if(!o.NumberHelper.isInteger(t)||t<0)throw new i.CryptoError("Offset must be a number >= 0");if(!o.NumberHelper.isInteger(r)||r<0)throw new i.CryptoError("Length must be a number >= 0");if(r+t>e.length)throw new i.CryptoError("The offset + length is beyond the length of the trits");let a=t,c=r;do{let t=0;const r=c<s.HASH_LENGTH?c:s.HASH_LENGTH;for(;t<r;)this._state[t++]=e[a++];this.transform(),c-=s.HASH_LENGTH}while(c>0)}squeeze(e,t,r){if(!n.ObjectHelper.isType(e,Int8Array)||0===e.length)throw new i.CryptoError("Trits must be a non empty Int8Array");if(!o.NumberHelper.isInteger(t)||t<0)throw new i.CryptoError("Offset must be a number >= 0");if(!o.NumberHelper.isInteger(r)||r<0)throw new i.CryptoError("Length must be a number >= 0");if(r+t>e.length)throw new i.CryptoError("The offset + length is beyond the length of the trits");let a=t,c=r;do{let t=0;const o=c<s.HASH_LENGTH?r:s.HASH_LENGTH;for(;t<o;)e[a++]=this._state[t++];this.transform(),c-=s.HASH_LENGTH}while(c>0)}transform(){let e,t=0;for(let r=0;r<this._numberOfRounds;r++){e=new Int8Array(this._state.slice());for(let r=0;r<s.STATE_LENGTH;r++)this._state[r]=s.TRUTH_TABLE[e[t]+(e[t+=t<365?364:-365]<<2)+5]}}}s.HASH_LENGTH=243,s.NUMBER_OF_ROUNDS=81,s.STATE_LENGTH=3*s.HASH_LENGTH,s.TRUTH_TABLE=new Int8Array([1,0,-1,2,1,-1,0,2,-1,1,0]),t.Curl=s},function(e,t,r){Object.defineProperty(t,"__esModule",{value:!0});const o=r(2),n=r(1),i=r(6),s=r(0),a=r(10);class c{constructor(){this._keccak=new i.Sha3(384,i.Sha3.KECCAK_PADDING,384)}getConstant(e){switch(e){case"HASH_LENGTH":case"BIT_HASH_LENGTH":case"BYTE_HASH_LENGTH":return c[e];default:throw new s.CryptoError(`Unknown constant requested ${e}`)}}getState(){}initialize(e){}reset(){this._keccak.reset()}absorb(e,t,r){if(!n.ObjectHelper.isType(e,Int8Array)||0===e.length)throw new s.CryptoError("Trits must be a non empty Int8Array");if(!o.NumberHelper.isInteger(t)||t<0)throw new s.CryptoError("Offset must be a number >= 0");if(!o.NumberHelper.isInteger(r)||r<0)throw new s.CryptoError("Length must be a number >= 0");if(r+t>e.length)throw new s.CryptoError("The offset + length is beyond the length of the trits");if(r%243!=0)throw new s.CryptoError(`Length must be a multiple of ${c.HASH_LENGTH}`,{length:r});let i=t,u=r;do{const t=e.slice(i,i+c.HASH_LENGTH);t[c.HASH_LENGTH-1]=0;const r=a.BigIntegerHelper.tritsToBigInteger(t,0,t.length),o=new ArrayBuffer(c.BYTE_HASH_LENGTH);a.BigIntegerHelper.bigIntegerToBytes(r,o,0),this._keccak.update(o),i+=c.HASH_LENGTH,u-=c.HASH_LENGTH}while(u>0)}squeeze(e,t,r){if(!n.ObjectHelper.isType(e,Int8Array)||0===e.length)throw new s.CryptoError("Trits must be a non empty Int8Array");if(!o.NumberHelper.isInteger(t)||t<0)throw new s.CryptoError("Offset must be a number >= 0");if(!o.NumberHelper.isInteger(r)||r<0)throw new s.CryptoError("Length must be a number >= 0");if(r+t>e.length)throw new s.CryptoError("The offset + length is beyond the length of the trits");if(r%243!=0)throw new s.CryptoError(`Length must be a multiple of ${c.HASH_LENGTH}`,{length:r});let i=t,u=r;do{const t=this._keccak.digest(),r=a.BigIntegerHelper.bytesToBigInteger(t,0,c.BYTE_HASH_LENGTH),o=new Int8Array(c.HASH_LENGTH);a.BigIntegerHelper.bigIntegerToTrits(r,o,0,c.HASH_LENGTH),o[c.HASH_LENGTH-1]=0;let n=0;for(;n<c.HASH_LENGTH;)e[i++]=o[n++];const s=new DataView(t);for(n=0;n<s.byteLength;n++)s.setUint8(n,255^s.getUint8(n));this._keccak.update(t),u-=c.HASH_LENGTH}while(u>0)}}c.HASH_LENGTH=243,c.BIT_HASH_LENGTH=384,c.BYTE_HASH_LENGTH=c.BIT_HASH_LENGTH/8,t.Kerl=c},function(e,t,r){Object.defineProperty(t,"__esModule",{value:!0});const o=r(3),n=r(2),i=r(1),s=o.__importDefault(r(19)),a=r(0);class c{static tritsToBigInteger(e,t,r){if(!i.ObjectHelper.isType(e,Int8Array)||0===e.length)throw new a.CryptoError("The trits must be a non empty Int8Array");if(!n.NumberHelper.isInteger(t)||t<0)throw new a.CryptoError("The offset must be a number >= 0");if(!n.NumberHelper.isInteger(r)||r<=0)throw new a.CryptoError("The length must be a number > 0");if(t+r>e.length)throw new a.CryptoError("The offset + length is beyond the length of the array");let o=s.default.zero;for(let n=r-1;n>=0;n--)o=o.multiply(c.RADIX).add(s.default(e[t+n]));return o}static bigIntegerToTrits(e,t,r,o){if(!i.ObjectHelper.isType(e,s.default))throw new a.CryptoError("The value must be a bigInteger type");if(!i.ObjectHelper.isType(t,Int8Array))throw new a.CryptoError("The trits must be an Int8Array");if(!n.NumberHelper.isInteger(r)||r<0)throw new a.CryptoError("The offset must be a number >= 0");if(!n.NumberHelper.isInteger(o)||o<=0)throw new a.CryptoError("The length must be a number > 0");if(r+o>t.length)throw new a.CryptoError("The offset + length is beyond the length of the array");let u=e.compareTo(s.default.zero)<0?e.negate():e;for(let e=0;e<o;e++){const o=u.divmod(c.RADIX);u=o.quotient;let n=o.remainder;n>c.MAX_TRIT_VALUE&&(n=c.MIN_TRIT_VALUE,u=u.add(s.default[1])),t[r+e]=n.toJSNumber()}if(e.compareTo(s.default.zero)<0)for(let e=0;e<o;e++)t[r+e]=0===t[r+e]?0:-t[r+e]}static bigIntegerToBytes(e,t,r){if(!i.ObjectHelper.isType(e,s.default))throw new a.CryptoError("The value must be a bigInteger type");if(!i.ObjectHelper.isType(t,ArrayBuffer)||0===t.byteLength)throw new a.CryptoError("The destination must be an array");if(!n.NumberHelper.isInteger(r)||r<0)throw new a.CryptoError("The offset must be a number >= 0");if(t.byteLength-r<c.BYTE_HASH_LENGTH)throw new a.CryptoError(`Destination array has invalid size, it must be at least ${c.BYTE_HASH_LENGTH}`);const o=e.isNegative()?-1:0;let u=e.toString(16);-1===o&&(u=u.slice(1)),u.length%2==1&&(u=`0${u}`);const l=u.match(/[0-9a-f]{2}/g),p=new Int8Array(l.map(e=>parseInt(`0x${e}`,16)));-1===o&&c.twosComplement(p);const f=new DataView(t);let y=r;for(;y+p.length<c.BYTE_HASH_LENGTH;)f.setInt8(y++,o);for(let e=p.length;e-- >0;)f.setInt8(y++,p[p.length-1-e])}static bytesToBigInteger(e,t,r){if(!i.ObjectHelper.isType(e,ArrayBuffer)||0===e.byteLength)throw new a.CryptoError("The source must be a non empty number array");if(!n.NumberHelper.isInteger(t)||t<0)throw new a.CryptoError("The offset must be a number >= 0");if(!n.NumberHelper.isInteger(r)||r<=0)throw new a.CryptoError("The length must be a number > 0");if(e.byteLength-t<c.BYTE_HASH_LENGTH)throw new a.CryptoError(`Source array has invalid size, it must be at least ${c.BYTE_HASH_LENGTH}`);const o=new DataView(e);let u=new Int8Array(o.byteLength);for(let e=0;e<o.byteLength;e++)u[e]=o.getInt8(e+t);let l=0;const p=u[0],f=p<0;if(0===p||-1===p){for(;u[l]===p&&l<u.length-1;)l++;u=u.slice(l)}f&&c.twosComplement(u);let y=f?"-":"";const h=new DataView(u.buffer);for(let e=0;e<h.byteLength;e++)y+=`00${h.getUint8(e).toString(16)}`.slice(-2);return s.default(y,16)}static twosComplement(e){for(let t=0;t<e.length;t++)e[t]=~e[t];let t=e.length-1;do{e[t]++}while(0===e[t--]&&t>0)}}c.RADIX=s.default(3),c.MAX_TRIT_VALUE=c.RADIX.minus(1).divide(2),c.MIN_TRIT_VALUE=c.MAX_TRIT_VALUE.negate(),c.BIT_HASH_LENGTH=384,c.BYTE_HASH_LENGTH=c.BIT_HASH_LENGTH/8,t.BigIntegerHelper=c},function(e,t){e.exports=n},function(e,t){e.exports=i},function(e,t){e.exports=s},function(e,t,r){Object.defineProperty(t,"__esModule",{value:!0});const o=r(1),n=r(5),i=r(15),s=r(12),a=r(0),c=r(4);t.TransactionHelper=class{static hash(e){if(!o.ObjectHelper.isType(e,i.Transaction))throw new a.CryptoError("The transaction must be of type Transaction");const t=c.SpongeFactory.instance().create("curl"),r=s.Trits.fromTrytes(e.toTrytes()).toArray();t.initialize(),t.absorb(r,0,r.length);const u=new Int8Array(t.getConstant("HASH_LENGTH"));return t.squeeze(u,0,u.length),n.Hash.fromTrytes(s.Trits.fromArray(u).toTrytes())}}},function(e,t){e.exports=a},function(e,t,r){Object.defineProperty(t,"__esModule",{value:!0});const o=r(3);o.__exportStar(r(6),t),o.__exportStar(r(0),t),o.__exportStar(r(18),t),o.__exportStar(r(4),t),o.__exportStar(r(20),t),o.__exportStar(r(10),t),o.__exportStar(r(14),t),o.__exportStar(r(24),t),o.__exportStar(r(8),t),o.__exportStar(r(9),t)},function(e,t){e.exports=c},function(e,t,r){Object.defineProperty(t,"__esModule",{value:!0});const o=r(7);class n extends o.FactoryBase{constructor(){super()}static instance(){return n._instance||(n._instance=new n),n._instance}getInstance(){return n.instance()}}t.ProofOfWorkFactory=n},function(e,t){e.exports=u},function(e,t,r){Object.defineProperty(t,"__esModule",{value:!0});const o=r(11),n=r(2),i=r(1),s=r(21),a=r(22),c=r(5),u=r(23),l=r(12),p=r(13),f=r(0),y=r(4);class h{static subseed(e,t,r="curl27"){if(!i.ObjectHelper.isType(e,Int8Array))throw new f.CryptoError("The seed must be of type Int8Array");if(!n.NumberHelper.isInteger(t)||t<0)throw new f.CryptoError("The index must be an integer >= 0");if(!y.SpongeFactory.instance().exists(r))throw new f.CryptoError(`The spongeType must be one of [${y.SpongeFactory.instance().types().join(", ")}]`);const o=y.SpongeFactory.instance().create(r),s=o.getConstant("HASH_LENGTH");o.initialize();const a=e.slice();let c=t;for(;c-- >0;)for(let e=0;e<a.length&&++a[e]>h.MAX_TRIT_VALUE;e++)a[e]=h.MIN_TRIT_VALUE;const u=new Int8Array(s);return o.absorb(a,0,a.length),o.squeeze(u,0,u.length),u}static key(e,t,r,o="kerl"){if(!i.ObjectHelper.isType(e,c.Hash))throw new f.CryptoError("The seed must be of type Hash");if(!n.NumberHelper.isInteger(t)||t<0)throw new f.CryptoError("The index must be an integer >= 0");if(!n.NumberHelper.isInteger(r)||r<a.AddressSecurity.low||r>a.AddressSecurity.high)throw new f.CryptoError("The security must be an integer >= 1 and <= 3");if(!y.SpongeFactory.instance().exists(o))throw new f.CryptoError(`The spongeType must be one of [${y.SpongeFactory.instance().types().join(", ")}]`);const s=l.Trits.fromTrytes(e.toTrytes()),u=l.Trits.fromNumber(t),p=l.Trits.add(s,u).toArray(),d=p.length,_=y.SpongeFactory.instance().create(o),b=_.getConstant("HASH_LENGTH");_.initialize(),_.absorb(p,0,d),_.squeeze(p,0,d),_.reset(),_.absorb(p,0,d);const T=new Int8Array(h.NUMBER_OF_FRAGMENT_CHUNKS*b*r);let g=0;const H=new Int8Array(d);let w=r;for(;w-- >0;)for(let e=0;e<h.NUMBER_OF_FRAGMENT_CHUNKS;e++){_.squeeze(H,0,d);for(let e=0;e<b;e++)T[g++]=H[e]}return T}static digests(e,t="kerl"){if(!i.ObjectHelper.isType(e,Int8Array))throw new f.CryptoError("The subseed must be of type Int8Array");if(!y.SpongeFactory.instance().exists(t))throw new f.CryptoError(`The spongeType must be one of [${y.SpongeFactory.instance().types().join(", ")}]`);const r=y.SpongeFactory.instance().create(t),o=r.getConstant("HASH_LENGTH"),n=o*h.NUMBER_OF_FRAGMENT_CHUNKS;if(e.length%n!=0)throw new f.CryptoError(`The subseed length must be a multiple of ${n}`);const s=h.MAX_TRYTE_VALUE-h.MIN_TRYTE_VALUE,a=e.length/n,c=new Int8Array(a*o);let u;for(let t=0;t<a;t++){const i=t*n,a=e.slice(i,i+n);for(let e=0;e<h.NUMBER_OF_FRAGMENT_CHUNKS;e++){const t=e*o;u=a.slice(t,t+o);for(let e=0;e<s;e++)r.reset(),r.absorb(u,0,u.length),r.squeeze(u,0,o);for(let e=0;e<o;e++)a[t+e]=u[e]}r.reset(),r.absorb(a,0,a.length),r.squeeze(u,0,o);const l=t*o;for(let e=0;e<o;e++)c[l+e]=u[e]}return c}static address(e,t="kerl"){if(!i.ObjectHelper.isType(e,Int8Array))throw new f.CryptoError("The digests must be of type Int8Array");if(!y.SpongeFactory.instance().exists(t))throw new f.CryptoError(`The spongeType must be one of [${y.SpongeFactory.instance().types().join(", ")}]`);const r=y.SpongeFactory.instance().create(t),o=r.getConstant("HASH_LENGTH");if(e.length%o!=0)throw new f.CryptoError(`Invalid digests length, must be a multiple of ${o}`);r.initialize(),r.absorb(e,0,e.length);const n=new Int8Array(o);return r.squeeze(n,0,n.length),n}static digest(e,t,r="kerl"){if(!i.ObjectHelper.isType(e,Int8Array))throw new f.CryptoError("The normalizedBundleFragment must be of type Int8Array");if(!i.ObjectHelper.isType(t,Int8Array))throw new f.CryptoError("The signatureMessageFragment must be of type Int8Array");if(!y.SpongeFactory.instance().exists(r))throw new f.CryptoError(`The spongeType must be one of [${y.SpongeFactory.instance().types().join(", ")}]`);let o;const n=y.SpongeFactory.instance().create(r),s=n.getConstant("HASH_LENGTH");n.initialize();for(let i=0;i<h.NUMBER_OF_FRAGMENT_CHUNKS;i++){o=new Int8Array(t.slice(i*s,(i+1)*s));for(let t=e[i]-h.MIN_TRYTE_VALUE;t>0;t--){const e=y.SpongeFactory.instance().create(r);e.initialize(),e.absorb(o,0,o.length),e.squeeze(o,0,e.getConstant("HASH_LENGTH"))}n.absorb(o,0,o.length)}return n.squeeze(o,0,n.getConstant("HASH_LENGTH")),o}static subseedToDigest(e,t,r="curl27"){if(!i.ObjectHelper.isType(e,Int8Array))throw new f.CryptoError("The subseed must be of type Int8Array");if(!n.NumberHelper.isInteger(t)||t<a.AddressSecurity.low||t>a.AddressSecurity.high)throw new f.CryptoError("The security must be an integer >= 1 and <= 3");if(!y.SpongeFactory.instance().exists(r))throw new f.CryptoError(`The spongeType must be one of [${y.SpongeFactory.instance().types().join(", ")}]`);const o=y.SpongeFactory.instance().create(r),s=y.SpongeFactory.instance().create(r),c=y.SpongeFactory.instance().create(r);o.initialize(),s.initialize(),c.initialize();const u=o.getConstant("HASH_LENGTH"),l=t*(u/3/h.RADIX*u)/u;let p=new Int8Array(u);o.absorb(e,0,e.length);for(let e=0;e<l;e++){o.squeeze(p,0,p.length);for(let e=0;e<h.MAX_TRYTE_VALUE-h.MIN_TRYTE_VALUE+1;e++)s.reset(),s.absorb(p,0,p.length),p=s.getState().slice(0,u);c.absorb(p,0,p.length)}return c.squeeze(p,0,p.length),p}static normalizedBundle(e,t="curl81"){if(!i.ObjectHelper.isType(e,c.Hash))throw new f.CryptoError("The bundleHash must be of type Hash");if(!y.SpongeFactory.instance().exists(t))throw new f.CryptoError(`The spongeType must be one of [${y.SpongeFactory.instance().types().join(", ")}]`);const r=y.SpongeFactory.instance().create(t).getConstant("HASH_LENGTH"),o=new Int8Array(h.NUMBER_OF_FRAGMENT_CHUNKS*h.NUMBER_OF_SECURITY_LEVELS),n=e.toTrytes().toString(),s=r/h.TRYTE_WIDTH/h.NUMBER_OF_SECURITY_LEVELS;for(let e=0;e<h.NUMBER_OF_SECURITY_LEVELS;e++){let t=0;for(let r=0;r<s;r++){const i=n.charAt(e*s+r),a=l.Trits.fromTrytes(p.Trytes.fromString(i)).toNumber();o[e*s+r]=a,t+=a}if(t>=0){for(;t-- >0;)for(let t=0;t<s;t++)if(o[e*s+t]>h.MIN_TRYTE_VALUE){o[e*s+t]--;break}}else for(;t++<0;)for(let t=0;t<s;t++)if(o[e*s+t]<h.MAX_TRYTE_VALUE){o[e*s+t]++;break}}return o}static validateSignatures(e,t,r,n="kerl"){if(!i.ObjectHelper.isType(e,s.Address))throw new f.CryptoError("The expectedAddress must be of type Hash");if(!o.ArrayHelper.isTyped(t,u.SignatureMessageFragment))throw new f.CryptoError("The signatureMessageFragments must be an array of type SignatureMessageFragment");if(!i.ObjectHelper.isType(r,c.Hash))throw new f.CryptoError("The bundleHash must be of type Hash");if(!y.SpongeFactory.instance().exists(n))throw new f.CryptoError(`The spongeType must be one of [${y.SpongeFactory.instance().types().join(", ")}]`);const a=[],p=h.normalizedBundle(r),d=y.SpongeFactory.instance().create(n).getConstant("HASH_LENGTH");for(let e=0;e<3;e++)a[e]=p.slice(e*h.NUMBER_OF_FRAGMENT_CHUNKS,(e+1)*h.NUMBER_OF_FRAGMENT_CHUNKS);const _=new Int8Array(t.length*d);for(let e=0;e<t.length;e++){const r=h.digest(a[e%3],l.Trits.fromTrytes(t[e].toTrytes()).toArray());for(let t=0;t<d;t++)_[e*d+t]=r[t]}return e.toTrytes().toString()===l.Trits.fromArray(h.address(_)).toTrytes().toString()}static signatureMessageFragment(e,t,r="kerl"){if(!i.ObjectHelper.isType(e,Int8Array))throw new f.CryptoError("The normalizedBundleFragment must be of type Int8Array");if(!i.ObjectHelper.isType(t,Int8Array))throw new f.CryptoError("The keyFragment must be of type Int8Array");if(!y.SpongeFactory.instance().exists(r))throw new f.CryptoError(`The spongeType must be one of [${y.SpongeFactory.instance().types().join(", ")}]`);const o=t.slice();let n;const s=y.SpongeFactory.instance().create(r),a=s.getConstant("HASH_LENGTH");for(let t=0;t<27;t++){n=o.slice(t*a,(t+1)*a);for(let r=0;r<13-e[t];r++)s.initialize(),s.reset(),s.absorb(n,0,a),s.squeeze(n,0,a);for(let e=0;e<a;e++)o[t*a+e]=n[e]}return o}}h.NUMBER_OF_FRAGMENT_CHUNKS=27,h.NUMBER_OF_SECURITY_LEVELS=3,h.TRYTE_WIDTH=3,h.MIN_TRYTE_VALUE=-13,h.MAX_TRYTE_VALUE=13,h.MIN_TRIT_VALUE=-1,h.MAX_TRIT_VALUE=1,h.RADIX=3,t.ISS=h},function(e,t){e.exports=l},function(e,t){e.exports=p},function(e,t){e.exports=f},function(e,t,r){Object.defineProperty(t,"__esModule",{value:!0});const o=r(3),n=r(11),i=r(2),s=r(1),a=r(25),c=r(5),u=r(26),l=r(15),p=r(27),f=r(13),y=r(0),h=r(14);class d{constructor(e){this._timeService=e||new a.TimeService}initialize(){return o.__awaiter(this,void 0,void 0,function*(){return Promise.resolve()})}pow(e,t,r,a){return o.__awaiter(this,void 0,void 0,function*(){if(!s.ObjectHelper.isType(e,c.Hash))throw new y.CryptoError("The trunkTransaction must be an object of type Hash");if(!s.ObjectHelper.isType(t,c.Hash))throw new y.CryptoError("The branchTransaction must be an object of type Hash");if(!n.ArrayHelper.isTyped(r,f.Trytes))throw new y.CryptoError("The trytes must be an array of type Trytes");if(!i.NumberHelper.isInteger(a)||a<=0)throw new y.CryptoError("The minWeightMagnitude must be > 0");const o=[];let _;for(let n=0;n<r.length;n++){const i=l.Transaction.fromTrytes(r[n]);if(i.attachmentTimestamp=p.TryteNumber.fromNumber(this._timeService.msSinceEpoch()),i.attachmentTimestampLowerBound=p.TryteNumber.fromNumber(0),i.attachmentTimestampUpperBound=p.TryteNumber.fromNumber(d.MAX_TIMESTAMP_VALUE),s.ObjectHelper.isEmpty(_)){if(i.lastIndex.toNumber()!==i.currentIndex.toNumber())throw new y.CryptoError("Wrong bundle order. The bundle should be ordered in descending order from currentIndex");i.trunkTransaction=e,i.branchTransaction=t}else i.trunkTransaction=_,i.branchTransaction=e;const c=i.toTrytes(),f=yield this.singlePow(c,a);i.nonce=u.Tag.fromTrytes(f.sub(l.Transaction.LENGTH-u.Tag.LENGTH,u.Tag.LENGTH));const b=l.Transaction.fromTrytes(f);_=h.TransactionHelper.hash(b),o.push(b)}return o.reverse().map(e=>e.toTrytes())})}}d.MAX_TIMESTAMP_VALUE=(Math.pow(3,27)-1)/2,t.ProofOfWorkBase=d},function(e,t){e.exports=y},function(e,t){e.exports=h},function(e,t){e.exports=d}])});